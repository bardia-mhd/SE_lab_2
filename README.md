# آزمایش دوم

---

## گزارش

در این آزمایش از روش TDD استفاده شده است، به این صورت که ابتدا تست‌ها پیاده‌سازی شده‌اند و سپس از آن‌ها برای پیاده‌سازی کد استفاده شده است. برای همین، ابتدا کلاس Rectangle برای ساخت مستطیل تعریف شده و یک متد با نام compute_area برای محاسبه مساحت آن ایجاد شده است که با تعیین طول و عرض به دست می‌آید. تست مربوط به این کلاس نیز برای تعیین مساحت و ابعاد مستطیل به خوبی کار می‌کند. سپس کلاس Square تعریف شده است که از Rectangle ارث‌بری می‌کند. با این حال، وقتی می‌خواهیم ویژگی‌های پدر را به Square منتقل کنیم و طول و عرض جداگانه به آن بدهیم، با اصل LSP در تضاد هستیم. برای رفع این مشکل، ابتدا کلاس Shape به عنوان یک کلاس انتزاعی تعریف شده است که Rectangle و Square از آن ارث‌بری می‌کنند و متد compute_area را باید پیاده‌سازی کنند. همچنین در کلاس Square، یک متغیر به نام side تعریف شده است که تنها برای مربع قابل استفاده است. با استفاده از این روش، مشکلات برنامه قبلی با abstract کردن متد compute_area رفع شده و تست‌ها پاس می‌شوند.

---


مانطور که گفته شده است ابتدا تست‌ها برای کلاس Rectangle را پیاده‌سازی می‌کنیم. با پیاده‌سازی تست‌ها و اجرای آن برنامه ما با خطا رو به رو می شوند چون متد ها پیاده سازی نشده است:

<img width="417" alt="Screenshot 2023-07-22 092858" src="https://github.com/bardia-mhd/SE_lab_2/assets/22092861/4f65f7a0-4d6e-4bf6-b66f-7679ce1db1c0">
<img width="406" alt="Screenshot 2023-07-22 093456" src="https://github.com/bardia-mhd/SE_lab_2/assets/22092861/a5b71834-b418-4d4e-9e18-4c9df2bf9486">

پس از آن با اضافه کردن متد های کلاس Rectangle تست های آن پاس می شود:

<img width="352" alt="Screenshot 2023-07-22 101806" src="https://github.com/bardia-mhd/SE_lab_2/assets/22092861/bfd8b473-c953-457c-bb48-a62c2de025ab">

سپس تست های Square را پیاده سازی می‌کنیم. مشاهده می‌شود که مشابه مرحله قبل تست های پاس نمی‌شوند:

<img width="990" alt="Screenshot 2023-07-22 at 9 49 29 AM" src="https://github.com/bardia-mhd/SE_lab_2/assets/59197179/f10db7fd-9d22-4f17-917b-540b0e51c7ca">


همان طور که توضیح داده شد با تغییر ساختار کلاس ها و رعایت اصول شی گرایی و SOLID کلاس Square نیز پیاده سازی شده و تست های مربوط به آن نیز پاس می‌شود:

<img width="1205" alt="Screenshot 2023-07-22 at 10 13 45 AM" src="https://github.com/bardia-mhd/SE_lab_2/assets/59197179/8a147ddd-8bed-4742-9b98-fb74194e6fc6">


## سوالات

### هر یک از پنج اصل SOLID را در دو الی سه خط توضیح دهید.

---

اصل مسئولیت واحد (SRP) بیان می‌کند که هر کلاس باید فقط یک دلیل برای تغییر داشته باشد به این معنی که افراد مختلف نباید مجبور شوند برای تغییرات یک کلاس تطبیق دهند.

اصل باز-بسته (OCP) پیشنهاد می‌دهد که کلاس‌ها برای افزودن پیشرفته باز باشند اما برای تغییر بسته باشند. بنابراین باید بتوانیم عملکرد جدیدی را بدون لمس کد موجود برای یک کلاس اضافه کنیم. اصلاح کد موجود خطر ایجاد خطاهای احتمالی را به دنبال دارد بنابراین بهتر است هرچه ممکن است از این کار خودداری کنیم و از قابلیت اطمینان کد تست شده و قابل اعتماد production پشتیبانی کنیم.

اصل جایگزینی لیسکوف (LSP) می‌گوید که هر کلاس فرزند باید با کلاس پدر خود رابطه is-a داشته باشد. به این معنی که یک متد در کلاس فرزند نباید شرایط قبلی قوی‌تری داشته باشد یا شرایط پس‌زمینه قوی‌تری نسبت به پدرش داشته باشد. به عبارت دیگر یک فرزند باید کاری را انجام دهد که پدرش انجام می‌دهد و نباید از انجام آن امتناع کند و همچنین باید هر کار اضافی‌ای را که لازم است انجام دهد نیز انجام دهد.

اصل تجزیه و تحلیل رابطه (ISP) به ما توصیه می‌کند که چندین رابطه را به جای یک رابطه بزرگ که همه چیز را انجام می‌دهد ایجاد کنیم. ایجاد یک رابطه شبیه به god class باعث می‌شود که امکان پیاده‌سازی کلاس‌ها از رابطه‌های خاص وجود نداشته باشد و همه چیز با پیاده‌سازی رابطه در تمام کلاس‌ها انجام شود. به عبارت دیگر این اصل بیان می‌کند که بسیاری از رابطه‌های خاص مشتری بهتر از یک رابطه عمومی هستند و مشتریان نباید مجبور شوند کارایی را پیاده‌سازی کنند که به آن نیازی ندارند.

اصل برعکس شدن وابستگی (DIP) توصیه می‌کند که کلاس‌ها بر اساس انتزاع با یکدیگر تعاممتکی باشند. داشتن یک نمونه از یک کلاس مستقیما در یک کلاس دیگر مطلوب نیست زیرا این موضوع به ارتباطات بالایی منجر می‌شود. به عبارت دیگر کلاس‌های ما باید بر اساس انتزاع یا کلاس‌های انتزاعی وابستگی داشته باشند و به جای کلاس‌ها و توابع مستقیما از طریق کلاس‌ها و رابطه‌های انتزاعی وابستگی داشته باشند.

### اصول SOLID در کدام یک از گام‌های اصلی ایجاد نرم‌افزار (تحلیل نیازمندی‌ها طراحی پیاده‌سازی تست و استقرار) استفاده می‌شوند؟ توضیح دهید.

---

 اصول SOLID در طول تمام فرآیند توسعه نرم‌افزار از جمله تحلیل نیازمندی‌ها طراحی پیاده‌سازی تست و استقرار استفاده می‌شوند. این اصول بیشتر در گام تحلیل در ذهن باید شکل بگیرند.

در مرحله تحلیل نیازمندی‌ها اصل SRP به عنوان یک راهنمایی برای طراحی ساختار سیستم برای ارائه خدمات به مشتریان مورد استفاده قرار می‌گیرد. با این اصل باید سعی کنید هر کلاس فقط یک مسئولیت داشته باشد و تغییرات در یک کلاس برای یک دلیل ایجاد شده باشد.

در مرحله طراحی تمام اصول SOLID برای طراحی سیستم استفاده می‌شوند. اصل SRP برای تعریف مسئولیت‌های کلاس‌ها اصل OCP برای تعریف روش‌های ارتباطی بین کلاس‌ها و اصل LSP برای تعریف روابط بین کلاس‌های پدر و کلاس‌های فرزند به کار می‌روند. همچنین اصل ISP برای تعریف رابطه بین کلاس‌ها و روش‌های استفاده از آن‌ها و اصل DIP برای تعریف وابستگی‌های کلاس‌ها به یکدیگر بر اساس انتزاع استفاده می‌شوند.

در مرحله پیاده‌سازی اصل OCP و LSP برای طراحی ساختار کلاس‌ها و روابط بین کلاس‌های پدر و کلاس‌های فرزند استفاده می‌شوند. با استفاده از این دو اصل باید تلاش کنید که کلاس‌ها برای افزودن عملکرد جدید باز باشند و برای تغییر عملکرد موجود بسته باشند.

در مرحله تست اصل SRP برای اطمینان از اینکه هر کلاس فقط یک مسئولیت دارد و تغییرات در یک کلاس برای یک دلیل ایجاد شده‌اند مورد استفاده قرار می‌گیرد. همچنین اصل DIP برای انجام تست‌های وابسته به کلاس‌های دیگر و داشتن اعتماد به صحت عملکرد کلاس‌ها استفاده می‌شود.

در نهایت در مرحله استقرار اصل DIP برای تعریف وابستگی‌های کلاس‌ها به یکدیگر بر اساس انتزاع و امکان پیاده‌سازی کلاس‌ها به صورت مجزا و استفاده آن‌ها در محیط‌های مختلف استفاده می‌شود. همچنین اصل OCP برای افزودن عملکرد جدید به سیستم و آماده‌سازی آن برای تغییرات آینده استفاده می‌شود.

### در چرخه‌ی عمومی ایجاد نرم‌افزار، آزمون نرم‌افزار دیرتر از پیاده‌سازی نرم‌افزار انجام می‌شود، اما در روش TDD تست‌نویسی پیش از پیاده‌سازی شروع می‌شود. آیا این دو مورد با هم تناقضی دارند؟ توضیح دهید.

---

چرخه‌های عمومی و توسعه تست محور (TDD) رویکردهای متفاوتی برای توسعه نرم‌افزار هستند، اما لزوماً متناقض نیستند. چرخه‌های توسعه، مانند مدل‌های Waterfall و Iterative، شامل مراحل متفاوتی مانند برنامه‌ریزی، طراحی، ساخت، آزمایش و استقرار هستند که آزمایش معمولاً پس از اجرای کد انجام می‌شود. در مقابل، TDD بر نوشتن تست‌ها قبل از توسعه کد تاکید می‌کند. این رویکرد به توسعه دهندگان کمک می کند تا نیازمندی‌ها و مشکلات را در مراحل اولیه توسعه بهتر شناسایی کنند، کیفیت کد را بهبود بخشند و در نهایت تعداد باگ‌های احتمالی را کاهش دهد. با وجود تفاوت‌هایشان، هدف هر دو روش، ارائه نرم‌افزار با کیفیت بالا است و TDD می‌تواند در چرخه‌های توسعه معمول نیز برای بهبود کیفیت کد و کاهش تعداد باگ‌ها استفاده شود.

### فرض کنید در آزمایش بالا نیازی به تغییر ابعاد مستطیل نداشتیم. آیا در این حالت می‌توانستیم مربع را از مستطیل به ارث ببریم؟ توضیح دهید.

---

بله، در برنامه نویسی شی گرا، زمانی که اشیاء تغییرناپذیر هستند، مربع می تواند زیر کلاس مستطیل باشد، زیرا هر مربع طبق تعریف یک مستطیل است. مشکل زمانی به وجود می آید که اشیا قابل تغییر باشند. به عنوان مثال، اگر یک کلاس مربع، متدی برای تغییر عرض خود داشته باشد، استفاده از آن در مربع که به عرض و ارتفاع مساوی نیاز دارد، آن را به عنوان مربع نقض می‌کند. این مفهوم اصل LSP را در اصول Solid نقض می‌کند. بنابراین، اینکه آیا مربع می تواند یک زیرکلاس از Rectangle باشد، بستگی به متدهایی دارد که Rectangle دارد. اگر Rectangle دارای setterهای جداگانه برای طول و عرض باشد، Square یک زیرکلاس خوب ایجاد نمی کند.

